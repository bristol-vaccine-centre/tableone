% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/missing-data.R
\name{remove_missing}
\alias{remove_missing}
\title{Remove variables that fail a missing data test from models}
\usage{
remove_missing(
  df,
  ...,
  label_fn = label_extractor(df),
  significance_limit = 0.05,
  missingness_limit = 0.1
)
}
\arguments{
\item{df}{a dataframe of individual observations. If using the \code{tidyselect}
syntax data grouping defines the intervention group and should be present. if the
formula interface is used the first variable in the right hand side of the
formula is used as the intervention, in which case grouping is ignored.}

\item{...}{a list of formulae that specify the models that we want to check}

\item{label_fn}{(optional) a function for mapping a co-variate column name to
printable label. This is by default a no-operation and the output table
will contain the dataframe column names as labels. A simple alternative
would be some form of \link[dplyr:case_when]{dplyr::case_when} lookup, or a string function such
as \link[stringr:case]{stringr::str_to_sentence}. (N.b. this function must be vectorised).
Any value provided here will be overridden by the
\code{options("tableone.labeller" = my_label_fn)} which allows global setting of
the labeller.}

\item{significance_limit}{the limit at which we reject the hypothesis that the
data is missing at random.}

\item{missingness_limit}{the limit at which too much data is missing
to include the predictor.}
}
\value{
a list of formulae with missing parameters removed
}
\description{
Comparing missingness by looking at a table is good but we also want to update
models to exclude missing data from the predictors.
}
\examples{
df = iris \%>\%
  dplyr::mutate(Petal.Width = ifelse(
    stats::runif(dplyr::n()) < dplyr::case_when(
      Species == "setosa" ~ 0.2,
      Species == "virginica" ~ 0.1,
      TRUE~0
    ),
    NA,
    Petal.Width
  ))
remove_missing(df, ~ Species + Petal.Width + Sepal.Width, ~ Species + Petal.Length + Sepal.Length)
}
